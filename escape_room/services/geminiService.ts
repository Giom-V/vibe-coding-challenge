import { GoogleGenAI, Modality, Part } from "@google/genai";
import type { Item } from "../types";
import { ROOM_PROMPT, INITIAL_ITEMS, KEY_HALF_2_PROMPT } from '../constants';

if (!process.env.API_KEY) {
    throw new Error("API_KEY environment variable not set");
}

const ai = new GoogleGenAI({ apiKey: process.env.API_KEY });

const base64ToPart = (base64: string, mimeType: string): Part => {
    return {
        inlineData: {
            data: base64,
            mimeType,
        },
    };
};

export const generateImage = async (prompt: string, referenceImages: Part[] = []): Promise<string> => {
    try {
        const result = await ai.models.generateContent({
            model: 'gemini-2.5-flash-image-preview',
            contents: { parts: [{ text: prompt }, ...referenceImages] },
            config: {
                responseModalities: [Modality.IMAGE, Modality.TEXT],
            },
        });

        for (const part of result.candidates[0].content.parts) {
            if (part.inlineData) {
                return part.inlineData.data;
            }
        }
        throw new Error("No image was generated by the API.");
    } catch (error) {
        console.error("Gemini API call failed:", error);
        throw new Error("Failed to generate image. Please check your API key and network connection.");
    }
};

export const generateInitialAssets = async (
    theme: string,
    onProgress: (message: string) => void
): Promise<{ roomImage: string; items: Item[], keyHalf2Image: string }> => {
    
    onProgress("Sketching the room's layout...");
    const generatedItems: Item[] = INITIAL_ITEMS.map(item => ({ 
        ...item,
        subItems: item.subItems ? item.subItems.map(sub => ({...sub})) : undefined
    }));

    const referenceParts: Part[] = [];

    // Generate base images for main items
    for (const item of generatedItems) {
        onProgress(`Generating the ${item.name.toLowerCase()}...`);
        item.base64Image = await generateImage(item.initialPrompt);
        referenceParts.push(base64ToPart(item.base64Image, 'image/png'));
    }

    // Generate closeups and special states
    for (const item of generatedItems) {
        onProgress(`Imagining details for the ${item.name.toLowerCase()}...`);
        if (item.closeupPrompt) {
            item.closeupImage = await generateImage(
                item.closeupPrompt(false),
                item.base64Image ? [base64ToPart(item.base64Image, 'image/png')] : []
            );
        }

        // Chest has two closeup states
        if (item.id === 'chest' && item.closeupPrompt) {
            onProgress('Imagining the unlocked chest...');
            item.closeupImageUnlocked = await generateImage(
                item.closeupPrompt(true), // unlocked prompt
                item.base64Image ? [base64ToPart(item.base64Image, 'image/png')] : []
            );
        }

        // Desk has sub-items that need images
        if (item.id === 'desk' && item.subItems) {
            for (const subItem of item.subItems) {
                 onProgress(`Creating details for the ${subItem.name.toLowerCase()}...`);
                 if(subItem.closeupPrompt) {
                    subItem.closeupImage = await generateImage(subItem.closeupPrompt({}));
                 }
                 if(subItem.openPrompt) {
                    subItem.openImage = await generateImage(subItem.openPrompt);
                 }
            }
        }
    }
    
    onProgress("Hiding the final secret...");
    const keyHalf2Image = await generateImage(KEY_HALF_2_PROMPT);

    onProgress("Assembling the final scene...");
    const roomImage = await generateImage(ROOM_PROMPT(theme), referenceParts);

    onProgress("Finalizing assets...");

    return { roomImage, items: generatedItems, keyHalf2Image };
};
